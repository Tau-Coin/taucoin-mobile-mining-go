// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package types

import (
	"encoding/json"
	"errors"
	"math/big"

	"github.com/Tau-Coin/taucoin-mobile-mining-go/common"
	"github.com/Tau-Coin/taucoin-mobile-mining-go/common/hexutil"
)

var _ = (*TransferTxDataMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (t TransferTxData) MarshalJSON() ([]byte, error) {
	type TransferTxData struct {
		Version   hexutil.Bytes   `json:"version"     gencodec:"required"`
		Option    hexutil.Bytes   `json:"option"      gencodec:"required"`
		ChainID   hexutil.Bytes   `json:"chainid"     gencodec:"required"`
		Nonce     hexutil.Uint64  `json:"nounce"      gencodec:"required"`
		TimeStamp hexutil.Uint32  `json:"timestamp"   gencodec:"required"`
		Fee       *hexutil.Big    `json:"fee"         gencodec:"required"`
		V         *hexutil.Big    `json:"v"           gencodec:"required"`
		R         *hexutil.Big    `json:"r"           gencodec:"required"`
		S         *hexutil.Big    `json:"s"           gencodec:"required"`
		Sender    *common.Address `json:"sender"        rlp:"required"`
		Receiver  *common.Address `json:"receiver"        rlp:"required"`
		Amount    *hexutil.Big    `json:"value"    gencodec:"required"`
	}
	var enc TransferTxData
	enc.Version = hexutil.Bytes(t.Version)
	enc.Option = hexutil.Bytes(t.Option)
	enc.ChainID = hexutil.Bytes(t.ChainID)
	enc.Nonce = hexutil.Uint64(t.Nonce)
	enc.TimeStamp = hexutil.Uint32(t.TimeStamp)
	enc.Fee = (*hexutil.Big)(t.Fee)
	enc.V = (*hexutil.Big)(t.V)
	enc.R = (*hexutil.Big)(t.R)
	enc.S = (*hexutil.Big)(t.S)
	enc.Sender = t.Sender
	enc.Receiver = t.Receiver
	enc.Amount = (*hexutil.Big)(t.Amount)
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (t *TransferTxData) UnmarshalJSON(input []byte) error {
	type TransferTxData struct {
		Version   *hexutil.Bytes  `json:"version"     gencodec:"required"`
		Option    *hexutil.Bytes  `json:"option"      gencodec:"required"`
		ChainID   *hexutil.Bytes  `json:"chainid"     gencodec:"required"`
		Nonce     *hexutil.Uint64 `json:"nounce"      gencodec:"required"`
		TimeStamp *hexutil.Uint32 `json:"timestamp"   gencodec:"required"`
		Fee       *hexutil.Big    `json:"fee"         gencodec:"required"`
		V         *hexutil.Big    `json:"v"           gencodec:"required"`
		R         *hexutil.Big    `json:"r"           gencodec:"required"`
		S         *hexutil.Big    `json:"s"           gencodec:"required"`
		Sender    *common.Address `json:"sender"        rlp:"required"`
		Receiver  *common.Address `json:"receiver"        rlp:"required"`
		Amount    *hexutil.Big    `json:"value"    gencodec:"required"`
	}
	var dec TransferTxData
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Version == nil {
		return errors.New("missing required field 'version' for TransferTxData")
	}
	t.Version = OneByte(*dec.Version)
	if dec.Option == nil {
		return errors.New("missing required field 'option' for TransferTxData")
	}
	t.Option = OneByte(*dec.Option)
	if dec.ChainID == nil {
		return errors.New("missing required field 'chainid' for TransferTxData")
	}
	t.ChainID = Byte32s(*dec.ChainID)
	if dec.Nonce == nil {
		return errors.New("missing required field 'nounce' for TransferTxData")
	}
	t.Nonce = uint64(*dec.Nonce)
	if dec.TimeStamp == nil {
		return errors.New("missing required field 'timestamp' for TransferTxData")
	}
	t.TimeStamp = uint32(*dec.TimeStamp)
	if dec.Fee == nil {
		return errors.New("missing required field 'fee' for TransferTxData")
	}
	t.Fee = (*big.Int)(dec.Fee)
	if dec.V == nil {
		return errors.New("missing required field 'v' for TransferTxData")
	}
	t.V = (*big.Int)(dec.V)
	if dec.R == nil {
		return errors.New("missing required field 'r' for TransferTxData")
	}
	t.R = (*big.Int)(dec.R)
	if dec.S == nil {
		return errors.New("missing required field 's' for TransferTxData")
	}
	t.S = (*big.Int)(dec.S)
	if dec.Sender != nil {
		t.Sender = dec.Sender
	}
	if dec.Receiver != nil {
		t.Receiver = dec.Receiver
	}
	if dec.Amount == nil {
		return errors.New("missing required field 'value' for TransferTxData")
	}
	t.Amount = (*big.Int)(dec.Amount)
	return nil
}
